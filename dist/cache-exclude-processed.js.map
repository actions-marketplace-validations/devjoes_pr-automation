{"version":3,"sources":["../src/cache-exclude-processed.js"],"names":["iter","cache","hydrateCache","runAction","action","cachedIterator","iterateFromCache","modifiedPrNumbers","length","filter","pr","indexOf","number","i","push"],"mappings":";;;;;;;AAAe,wBAAgBA,IAAhB,EAAsB;AACnC,MAAIC,KAAK,GAAG,MAAMC,YAAY,CAACF,IAAD,CAA9B;AACA,SAAO;AACLG,IAAAA,SAAS,EAAE,MAAMC,MAAN,IAAgB;AACzB,YAAMC,cAAc,GAAGC,gBAAgB,CAACL,KAAD,CAAvC;AACA,YAAMM,iBAAiB,GAAG,MAAMH,MAAM,CAACC,cAAD,CAAtC,CAFyB,CAGzB;AACA;AACA;AACA;AACA;;AACA,UAAIE,iBAAiB,IAAIA,iBAAiB,CAACC,MAA3C,EAAmD;AACjDP,QAAAA,KAAK,GAAGA,KAAK,CAACQ,MAAN,CAAaC,EAAE,IAAIH,iBAAiB,CAACI,OAAlB,CAA0BD,EAAE,CAACE,MAA7B,CAAnB,CAAR;AACD;;AACD,aAAON,gBAAgB,CAACL,KAAD,CAAvB;AACD;AAbI,GAAP;AAeD;;AAED,gBAAgBK,gBAAhB,CAAiCL,KAAjC,EAAwC;AACtC;AACA,OAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,KAAK,CAACO,MAA1B,EAAkCK,CAAC,EAAnC,EAAuC;AACrC;AACA;AACA,UAAMZ,KAAK,CAACY,CAAD,CAAX;AACD;AACF;;AAED,eAAeX,YAAf,CAA4BF,IAA5B,EAAkC;AAChC,QAAMC,KAAK,GAAG,EAAd;;AACA,aAAW,IAAIY,CAAf,IAAoBb,IAApB,EAA0B;AACxBC,IAAAA,KAAK,CAACa,IAAN,CAAWD,CAAX;AACD;;AACD,SAAOZ,KAAP;AACD","sourcesContent":["export default async function (iter) {\r\n  let cache = await hydrateCache(iter);\r\n  return {\r\n    runAction: async action => {\r\n      const cachedIterator = iterateFromCache(cache);\r\n      const modifiedPrNumbers = await action(cachedIterator);\r\n      // If we have done something to a PR then we don't want to process it in subsequent steps wait till next run.\r\n      // TODO:\r\n      //    Be a bit more clever about cache invalidation\r\n      //    Some actions are atomic and should trigger a full refresh of the (latest and now correct) data.\r\n      //    Some actions can still process PRs that we currently filter out.\r\n      if (modifiedPrNumbers && modifiedPrNumbers.length) {\r\n        cache = cache.filter(pr => modifiedPrNumbers.indexOf(pr.number));\r\n      }\r\n      return iterateFromCache(cache);\r\n    },\r\n  };\r\n}\r\n\r\nasync function* iterateFromCache(cache) {\r\n  //TODO: It would be nice if we hydrated the cache whilst providing results, would use less RAM & be faster for initial PRs\r\n  for (let i = 0; i < cache.length; i++) {\r\n    // Whilst this doesn't actaully need to be async we should really be able to use the output\r\n    // of getPrs anywhere that we use prsCache. Also see todo above.\r\n    yield cache[i];\r\n  }\r\n}\r\n\r\nasync function hydrateCache(iter) {\r\n  const cache = [];\r\n  for await (let i of iter) {\r\n    cache.push(i);\r\n  }\r\n  return cache;\r\n}\r\n"],"file":"cache-exclude-processed.js"}